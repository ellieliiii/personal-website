"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/projects/page",{

/***/ "(app-pages-browser)/./src/data/projects/content/llm-coding-eval.ts":
/*!******************************************************!*\
  !*** ./src/data/projects/content/llm-coding-eval.ts ***!
  \******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   content: function() { return /* binding */ content; },\n/* harmony export */   description: function() { return /* binding */ description; }\n/* harmony export */ });\nconst description = \"\\nCan inserted errors improve the performance of LLMs? This project investigates the impact of inserting errors in proposed coding solutions and if the performance of LLMs can be improved by doing so.\\n\";\nconst content = '\\n<h3>Introduction</h2>\\n\\n<p>Large Language Models (LLMs), such as GPT-3.5 and GPT-4, have recently shown significant progress in their code generation abilities. These models can take in natural language instructions and generate code that meets the user\\'s instructions. However, the code generated by these models is often incorrect, due to both logical and syntactical errors. This project introduces a novel prompt engineering technique, <em>use mistake</em>, which first asks the LLM to construct an erroneous response to the coding problem. Then, that code is passed along with the original prompt to construct the final response. To benchmark the prompting techniques, two code evaluation datasets were used: HumanEval and PythonSaga. The <em>use mistake</em> technique achieved better performance than the standard coding attempt benchmark on the HumanEval dataset with 10 passes. An exploratory analysis was also conducted on how different prompting methods fail specific coding problems.</p>\\n\\n<h3>Data</h2>\\n\\n<p>Two different datasets were used to evaluate the effects of various prompting techniques on LLM code generation. The first dataset was <a href=\"https://github.com/openai/human-eval\">HumanEval</a>, a code evaluation dataset that contains 164 hand-crafted Python basic programming problems, designed to ensure that LLMs were not directly trained on these problems. Each of these problems contains a prompt with the method header and example inputs/outputs, along with an example solution and unit tests for the generated code. A significant benefit of using HumanEval is that the code automating the testing of LLM-generated outputs is publicly available. Since its creation in 2021, HumanEval has been widely used to evaluate and test code generation models. The second dataset, <a href=\"https://anonymous.4open.science/r/PythonSaga\">PythonSaga</a>, was recently released in 2024 and contains 185 Python programming problems. These problems were curated from popular coding platforms Geek-for-Geeks and LeetCode. The authors reformulated the problems taken from these coding platforms to maintain the same underlying functionality while transforming the prompting text to make it harder for LLMs to pattern-match the prompt, forcing them to recognize the underlying concepts in different contexts.</p>\\n\\n<h3>Methodology</h2>\\n\\n<img src=\"/projects/llm-coding-eval/proposal.jpg\" alt=\"Design\">\\n\\n<p>This section describes the four different prompting methods tested with LLM code generation.</p>\\n\\n<h4>Attempt</h3>\\n<p>The first prompting method was passing the raw prompt of the coding task from the dataset in use. The purpose of this attempt is to act as a baseline to compare the performance of our other prompting methods to. The code generated by this raw attempt is also used in our second technique.</p>\\n\\n<h4>Use Attempt</h3>\\n<p>The next prompting method is the <em>use attempt</em> method which provides the LLM with an example LLM generated solution when asking it to solve the same problem. The direct prompt used was:</p>\\n\\n<blockquote>This is an attempt to the function: \\\\n {problem} \\\\n {attempt} \\\\n If the solution is correct please output the existing function code. If the solution is incorrect fix and output the function code. \\\\n {problem}</blockquote>\\n\\n<p>{problem} contains the raw prompt and {attempt} contains the output of a previous raw attempt. The idea of this strategy was to see if providing the LLM with an example solution could improve its accuracy/identification of errors in the previous attempt\\'s strategy.</p>\\n\\n<h4>Mistake</h3>\\n<p>Our next prompting method was the mistake method. This is where we asked the LLM to incorrectly answer the coding problem that we provided it. The prompt we used was:</p>\\n\\n<blockquote>Complete this task with mistakes. Only return your addition to the existing code. Do not repeat the function header. \\\\n {problem}.</blockquote>\\n\\n<p>The purpose of this method is to be used in the use mistake prompting method, which requires an example erroneous LLM output.</p>\\n\\n<h4>Use Mistake</h3>\\n<p>The final prompting method is our novel <em>use mistake</em> method. In this method, we passed an erroneous example LLM generated solution along with the problem. The prompt used was:</p>\\n\\n<blockquote>This is an attempt to the function: \\\\n {problem} \\\\n {attempt} \\\\n If the solution is correct please output the existing function code. If the solution is incorrect fix and output the function code. \\\\n {problem}.</blockquote>\\n\\n<p>The intention behind this method is to prompt the LLM to be more cognizant and mindful of errors, such as the ones in the wrong attempt that they are passed. We hoped that this would then correlate to reduced number of errors and better generated solutions.</p>\\n\\n<h3>Evaluation</h2>\\n\\n<p>We used both HumanEval and PythonSaga to evaluate our code prompting methods. The evaluation method used in the HumanEval paper, pass @ k, has become the standard for measuring LLM code generation accuracy. This strategy involves passing the same prompt to the LLM k times. If any of the k generations pass all of the unit tests, then this problem is given a score of \"1\" for solving the problem. Otherwise, it is given a score of \"0\". Calculating the mean of these scores across the code evaluation dataset that is being used then yields the final score. We calculated pass @ 1, 5, and 10 for all of the different prompting methods. Furthermore, we propose a novel combined metric that shows the overall combined power of the <em>attempt</em> and  <em>use mistake</em> methods. Simply, this metric checks if either one of these prompting methods yielded a correct output.</p>\\n\\n<h3>Implementation Details</h2>\\n\\n<p>For our LLM, we use OpenAI\\'s GPT-3.5 Turbo with a temperature of 0.8, as that is the standard temperature used with HumanEval. We chose GPT-3.5 Turbo due to significantly lower associated costs for repeated LLM passes with different prompts and methods and GPT-4 Turbo already having the best performance on the HumanEval dataset. We hoped to increase performance with a worse but much cheaper model to show the benefits of our prompting technique. After 10 passes for each problem, we ran the generated code in a Docker container to benchmark using the unit tests and store the results. We also stored the individual LLM generated outputs and benchmark results for more detailed output analysis. Check out our code <a href=\"https://github.com/mchales/llm-coding-eval\">here</a>.</p>\\n\\n<h3>Results</h2>\\n\\n<p>Figure 1</p>\\n<img src=\"/projects/llm-coding-eval/figure1.png\" alt=\"Figure 1\"  width=\"500\">\\n\\n<p>Figure 2</p>\\n<img src=\"/projects/llm-coding-eval/figure2.png\" alt=\"Figure 2\"  width=\"500\">\\n\\n<p>Figure 3</p>\\n<img src=\"/projects/llm-coding-eval/figure3.png\" alt=\"Figure 3\"  width=\"500\">\\n\\n<p>Looking at Figure 1 and Figure 2, we can clearly see that the LLM performs significantly better on HumanEval than PythonSaga. This makes sense as PythonSaga is much newer, and thus GPT-3.5 has had less exposure to its problems. Furthermore, as the authors of PythonSaga transformed the coding prompts to be harder for LLMs to identify the underlying question/function of the problem, it makes sense that all prompting methods perform significantly worse on it. For HumanEval, the <em>use mistake</em> prompting method had the best performance, while for PythonSaga, the <em>attempt</em> method performed the best. Given that PythonSaga\\'s involved preprocessing result in significantly poorer overall results, and HumanEval is the more tested dataset, we conducted most of our analysis with HumanEval.</p>\\n\\n<p>Interestingly, the <em>attempt</em> and <em>use mistake</em> methods don\\'t fail the same problems. We can combine their results to create the metric <em>Combined</em> for HumanEval seen in Figure 3.</p>\\n\\n<h3>Code Example</h3>\\n<p>One problem which <em>use mistake</em> succeeded while <em>attempt</em> did not was:</p>\\n\\n<blockquote>\"How many 7s are in numbers that are divisible by 11 or 13 between 1 to n, where n is an input passed in.\"</blockquote>\\n\\n<p>The <em>attempt</em> method fails to understand that numbers can have multiple 7s, and that these need to be counted individually. An example generation is:</p>\\n\\n<pre><code>count = 0\\nfor i in range(1, n):\\n    if i % 11 == 0 or i % 13 == 0:\\n        if \\'7\\' in str(i):\\n            count += 1\\nreturn count\\n</code></pre>\\n\\n<p><em>use mistake</em> successfully answered this question with the generation:</p>\\n\\n<pre><code>count = 0\\nfor i in range(1, n):\\n    if i % 11 == 0 or i % 13 == 0:\\n        for digit in str(i):\\n            if digit == \\'7\\':\\n                count += 1\\nreturn count\\n</code></pre>\\n\\n<p>Interestingly, the <em>mistake</em> generated code for this solution is not close to the correct solution:</p>\\n\\n<pre><code>if i % 7 == 0:\\n    count += 1\\ncontinue\\nreturn count\\n</code></pre>\\n\\n<p>Although not always reliable, mistake-generated outputs can influence LLMs to solve problems they previously could not.</p>\\n\\n<h3>Conclusion BLAHBLAH</h2>\\n\\n<p>This project proposes a new prompting technique for LLMs that resulted in improved performance with HumanEval pass @ 10. More research will need to be done to explore repeatability and reliability of this technique.</p>\\n\\n<h3>Extra</h3>\\n\\n<table>\\n  <thead>\\n    <tr>\\n      <th>Prompting Technique</th>\\n      <th>HumanEval Pass@1</th>\\n      <th>HumanEval Pass@5</th>\\n      <th>HumanEval Pass@10</th>\\n      <th>PythonSaga Pass@1</th>\\n      <th>PythonSaga Pass@5</th>\\n      <th>PythonSaga Pass@10</th>\\n    </tr>\\n  </thead>\\n  <tbody>\\n    <tr>\\n      <td>Attempt</td>\\n      <td><strong>71.28</strong></td>\\n      <td>84.85</td>\\n      <td>89.02</td>\\n      <td><strong>18.81</strong></td>\\n      <td><strong>31.32</strong></td>\\n      <td><strong>35.68</strong></td>\\n    </tr>\\n    <tr>\\n      <td>Mistake</td>\\n      <td>10.06</td>\\n      <td>35.80</td>\\n      <td>53.05</td>\\n      <td>1.68</td>\\n      <td>7.46</td>\\n      <td>12.97</td>\\n    </tr>\\n    <tr>\\n      <td>Use Mistake</td>\\n      <td>70.79</td>\\n      <td><strong>88.41</strong></td>\\n      <td><strong>91.46</strong></td>\\n      <td>16.00</td>\\n      <td>27.57</td>\\n      <td>32.43</td>\\n    </tr>\\n    <tr>\\n      <td>Use Attempt</td>\\n      <td>66.65</td>\\n      <td>84.88</td>\\n      <td>87.80</td>\\n      <td>13.68</td>\\n      <td>24.49</td>\\n      <td>27.03</td>\\n    </tr>\\n  </tbody>\\n</table>\\n';\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9kYXRhL3Byb2plY3RzL2NvbnRlbnQvbGxtLWNvZGluZy1ldmFsLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQU8sTUFDUEEsY0FBZSw2TUFFYjtBQUVLLE1BQU1DLFVBQVcsaXdVQTJKdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2RhdGEvcHJvamVjdHMvY29udGVudC9sbG0tY29kaW5nLWV2YWwudHM/ZDcwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgXG5kZXNjcmlwdGlvbiA9IGBcbkNhbiBpbnNlcnRlZCBlcnJvcnMgaW1wcm92ZSB0aGUgcGVyZm9ybWFuY2Ugb2YgTExNcz8gVGhpcyBwcm9qZWN0IGludmVzdGlnYXRlcyB0aGUgaW1wYWN0IG9mIGluc2VydGluZyBlcnJvcnMgaW4gcHJvcG9zZWQgY29kaW5nIHNvbHV0aW9ucyBhbmQgaWYgdGhlIHBlcmZvcm1hbmNlIG9mIExMTXMgY2FuIGJlIGltcHJvdmVkIGJ5IGRvaW5nIHNvLlxuYDtcblxuZXhwb3J0IGNvbnN0IGNvbnRlbnQgPSBgXG48aDM+SW50cm9kdWN0aW9uPC9oMj5cblxuPHA+TGFyZ2UgTGFuZ3VhZ2UgTW9kZWxzIChMTE1zKSwgc3VjaCBhcyBHUFQtMy41IGFuZCBHUFQtNCwgaGF2ZSByZWNlbnRseSBzaG93biBzaWduaWZpY2FudCBwcm9ncmVzcyBpbiB0aGVpciBjb2RlIGdlbmVyYXRpb24gYWJpbGl0aWVzLiBUaGVzZSBtb2RlbHMgY2FuIHRha2UgaW4gbmF0dXJhbCBsYW5ndWFnZSBpbnN0cnVjdGlvbnMgYW5kIGdlbmVyYXRlIGNvZGUgdGhhdCBtZWV0cyB0aGUgdXNlcidzIGluc3RydWN0aW9ucy4gSG93ZXZlciwgdGhlIGNvZGUgZ2VuZXJhdGVkIGJ5IHRoZXNlIG1vZGVscyBpcyBvZnRlbiBpbmNvcnJlY3QsIGR1ZSB0byBib3RoIGxvZ2ljYWwgYW5kIHN5bnRhY3RpY2FsIGVycm9ycy4gVGhpcyBwcm9qZWN0IGludHJvZHVjZXMgYSBub3ZlbCBwcm9tcHQgZW5naW5lZXJpbmcgdGVjaG5pcXVlLCA8ZW0+dXNlIG1pc3Rha2U8L2VtPiwgd2hpY2ggZmlyc3QgYXNrcyB0aGUgTExNIHRvIGNvbnN0cnVjdCBhbiBlcnJvbmVvdXMgcmVzcG9uc2UgdG8gdGhlIGNvZGluZyBwcm9ibGVtLiBUaGVuLCB0aGF0IGNvZGUgaXMgcGFzc2VkIGFsb25nIHdpdGggdGhlIG9yaWdpbmFsIHByb21wdCB0byBjb25zdHJ1Y3QgdGhlIGZpbmFsIHJlc3BvbnNlLiBUbyBiZW5jaG1hcmsgdGhlIHByb21wdGluZyB0ZWNobmlxdWVzLCB0d28gY29kZSBldmFsdWF0aW9uIGRhdGFzZXRzIHdlcmUgdXNlZDogSHVtYW5FdmFsIGFuZCBQeXRob25TYWdhLiBUaGUgPGVtPnVzZSBtaXN0YWtlPC9lbT4gdGVjaG5pcXVlIGFjaGlldmVkIGJldHRlciBwZXJmb3JtYW5jZSB0aGFuIHRoZSBzdGFuZGFyZCBjb2RpbmcgYXR0ZW1wdCBiZW5jaG1hcmsgb24gdGhlIEh1bWFuRXZhbCBkYXRhc2V0IHdpdGggMTAgcGFzc2VzLiBBbiBleHBsb3JhdG9yeSBhbmFseXNpcyB3YXMgYWxzbyBjb25kdWN0ZWQgb24gaG93IGRpZmZlcmVudCBwcm9tcHRpbmcgbWV0aG9kcyBmYWlsIHNwZWNpZmljIGNvZGluZyBwcm9ibGVtcy48L3A+XG5cbjxoMz5EYXRhPC9oMj5cblxuPHA+VHdvIGRpZmZlcmVudCBkYXRhc2V0cyB3ZXJlIHVzZWQgdG8gZXZhbHVhdGUgdGhlIGVmZmVjdHMgb2YgdmFyaW91cyBwcm9tcHRpbmcgdGVjaG5pcXVlcyBvbiBMTE0gY29kZSBnZW5lcmF0aW9uLiBUaGUgZmlyc3QgZGF0YXNldCB3YXMgPGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvaHVtYW4tZXZhbFwiPkh1bWFuRXZhbDwvYT4sIGEgY29kZSBldmFsdWF0aW9uIGRhdGFzZXQgdGhhdCBjb250YWlucyAxNjQgaGFuZC1jcmFmdGVkIFB5dGhvbiBiYXNpYyBwcm9ncmFtbWluZyBwcm9ibGVtcywgZGVzaWduZWQgdG8gZW5zdXJlIHRoYXQgTExNcyB3ZXJlIG5vdCBkaXJlY3RseSB0cmFpbmVkIG9uIHRoZXNlIHByb2JsZW1zLiBFYWNoIG9mIHRoZXNlIHByb2JsZW1zIGNvbnRhaW5zIGEgcHJvbXB0IHdpdGggdGhlIG1ldGhvZCBoZWFkZXIgYW5kIGV4YW1wbGUgaW5wdXRzL291dHB1dHMsIGFsb25nIHdpdGggYW4gZXhhbXBsZSBzb2x1dGlvbiBhbmQgdW5pdCB0ZXN0cyBmb3IgdGhlIGdlbmVyYXRlZCBjb2RlLiBBIHNpZ25pZmljYW50IGJlbmVmaXQgb2YgdXNpbmcgSHVtYW5FdmFsIGlzIHRoYXQgdGhlIGNvZGUgYXV0b21hdGluZyB0aGUgdGVzdGluZyBvZiBMTE0tZ2VuZXJhdGVkIG91dHB1dHMgaXMgcHVibGljbHkgYXZhaWxhYmxlLiBTaW5jZSBpdHMgY3JlYXRpb24gaW4gMjAyMSwgSHVtYW5FdmFsIGhhcyBiZWVuIHdpZGVseSB1c2VkIHRvIGV2YWx1YXRlIGFuZCB0ZXN0IGNvZGUgZ2VuZXJhdGlvbiBtb2RlbHMuIFRoZSBzZWNvbmQgZGF0YXNldCwgPGEgaHJlZj1cImh0dHBzOi8vYW5vbnltb3VzLjRvcGVuLnNjaWVuY2Uvci9QeXRob25TYWdhXCI+UHl0aG9uU2FnYTwvYT4sIHdhcyByZWNlbnRseSByZWxlYXNlZCBpbiAyMDI0IGFuZCBjb250YWlucyAxODUgUHl0aG9uIHByb2dyYW1taW5nIHByb2JsZW1zLiBUaGVzZSBwcm9ibGVtcyB3ZXJlIGN1cmF0ZWQgZnJvbSBwb3B1bGFyIGNvZGluZyBwbGF0Zm9ybXMgR2Vlay1mb3ItR2Vla3MgYW5kIExlZXRDb2RlLiBUaGUgYXV0aG9ycyByZWZvcm11bGF0ZWQgdGhlIHByb2JsZW1zIHRha2VuIGZyb20gdGhlc2UgY29kaW5nIHBsYXRmb3JtcyB0byBtYWludGFpbiB0aGUgc2FtZSB1bmRlcmx5aW5nIGZ1bmN0aW9uYWxpdHkgd2hpbGUgdHJhbnNmb3JtaW5nIHRoZSBwcm9tcHRpbmcgdGV4dCB0byBtYWtlIGl0IGhhcmRlciBmb3IgTExNcyB0byBwYXR0ZXJuLW1hdGNoIHRoZSBwcm9tcHQsIGZvcmNpbmcgdGhlbSB0byByZWNvZ25pemUgdGhlIHVuZGVybHlpbmcgY29uY2VwdHMgaW4gZGlmZmVyZW50IGNvbnRleHRzLjwvcD5cblxuPGgzPk1ldGhvZG9sb2d5PC9oMj5cblxuPGltZyBzcmM9XCIvcHJvamVjdHMvbGxtLWNvZGluZy1ldmFsL3Byb3Bvc2FsLmpwZ1wiIGFsdD1cIkRlc2lnblwiPlxuXG48cD5UaGlzIHNlY3Rpb24gZGVzY3JpYmVzIHRoZSBmb3VyIGRpZmZlcmVudCBwcm9tcHRpbmcgbWV0aG9kcyB0ZXN0ZWQgd2l0aCBMTE0gY29kZSBnZW5lcmF0aW9uLjwvcD5cblxuPGg0PkF0dGVtcHQ8L2gzPlxuPHA+VGhlIGZpcnN0IHByb21wdGluZyBtZXRob2Qgd2FzIHBhc3NpbmcgdGhlIHJhdyBwcm9tcHQgb2YgdGhlIGNvZGluZyB0YXNrIGZyb20gdGhlIGRhdGFzZXQgaW4gdXNlLiBUaGUgcHVycG9zZSBvZiB0aGlzIGF0dGVtcHQgaXMgdG8gYWN0IGFzIGEgYmFzZWxpbmUgdG8gY29tcGFyZSB0aGUgcGVyZm9ybWFuY2Ugb2Ygb3VyIG90aGVyIHByb21wdGluZyBtZXRob2RzIHRvLiBUaGUgY29kZSBnZW5lcmF0ZWQgYnkgdGhpcyByYXcgYXR0ZW1wdCBpcyBhbHNvIHVzZWQgaW4gb3VyIHNlY29uZCB0ZWNobmlxdWUuPC9wPlxuXG48aDQ+VXNlIEF0dGVtcHQ8L2gzPlxuPHA+VGhlIG5leHQgcHJvbXB0aW5nIG1ldGhvZCBpcyB0aGUgPGVtPnVzZSBhdHRlbXB0PC9lbT4gbWV0aG9kIHdoaWNoIHByb3ZpZGVzIHRoZSBMTE0gd2l0aCBhbiBleGFtcGxlIExMTSBnZW5lcmF0ZWQgc29sdXRpb24gd2hlbiBhc2tpbmcgaXQgdG8gc29sdmUgdGhlIHNhbWUgcHJvYmxlbS4gVGhlIGRpcmVjdCBwcm9tcHQgdXNlZCB3YXM6PC9wPlxuXG48YmxvY2txdW90ZT5UaGlzIGlzIGFuIGF0dGVtcHQgdG8gdGhlIGZ1bmN0aW9uOiBcXFxcbiB7cHJvYmxlbX0gXFxcXG4ge2F0dGVtcHR9IFxcXFxuIElmIHRoZSBzb2x1dGlvbiBpcyBjb3JyZWN0IHBsZWFzZSBvdXRwdXQgdGhlIGV4aXN0aW5nIGZ1bmN0aW9uIGNvZGUuIElmIHRoZSBzb2x1dGlvbiBpcyBpbmNvcnJlY3QgZml4IGFuZCBvdXRwdXQgdGhlIGZ1bmN0aW9uIGNvZGUuIFxcXFxuIHtwcm9ibGVtfTwvYmxvY2txdW90ZT5cblxuPHA+e3Byb2JsZW19IGNvbnRhaW5zIHRoZSByYXcgcHJvbXB0IGFuZCB7YXR0ZW1wdH0gY29udGFpbnMgdGhlIG91dHB1dCBvZiBhIHByZXZpb3VzIHJhdyBhdHRlbXB0LiBUaGUgaWRlYSBvZiB0aGlzIHN0cmF0ZWd5IHdhcyB0byBzZWUgaWYgcHJvdmlkaW5nIHRoZSBMTE0gd2l0aCBhbiBleGFtcGxlIHNvbHV0aW9uIGNvdWxkIGltcHJvdmUgaXRzIGFjY3VyYWN5L2lkZW50aWZpY2F0aW9uIG9mIGVycm9ycyBpbiB0aGUgcHJldmlvdXMgYXR0ZW1wdCdzIHN0cmF0ZWd5LjwvcD5cblxuPGg0Pk1pc3Rha2U8L2gzPlxuPHA+T3VyIG5leHQgcHJvbXB0aW5nIG1ldGhvZCB3YXMgdGhlIG1pc3Rha2UgbWV0aG9kLiBUaGlzIGlzIHdoZXJlIHdlIGFza2VkIHRoZSBMTE0gdG8gaW5jb3JyZWN0bHkgYW5zd2VyIHRoZSBjb2RpbmcgcHJvYmxlbSB0aGF0IHdlIHByb3ZpZGVkIGl0LiBUaGUgcHJvbXB0IHdlIHVzZWQgd2FzOjwvcD5cblxuPGJsb2NrcXVvdGU+Q29tcGxldGUgdGhpcyB0YXNrIHdpdGggbWlzdGFrZXMuIE9ubHkgcmV0dXJuIHlvdXIgYWRkaXRpb24gdG8gdGhlIGV4aXN0aW5nIGNvZGUuIERvIG5vdCByZXBlYXQgdGhlIGZ1bmN0aW9uIGhlYWRlci4gXFxcXG4ge3Byb2JsZW19LjwvYmxvY2txdW90ZT5cblxuPHA+VGhlIHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gYmUgdXNlZCBpbiB0aGUgdXNlIG1pc3Rha2UgcHJvbXB0aW5nIG1ldGhvZCwgd2hpY2ggcmVxdWlyZXMgYW4gZXhhbXBsZSBlcnJvbmVvdXMgTExNIG91dHB1dC48L3A+XG5cbjxoND5Vc2UgTWlzdGFrZTwvaDM+XG48cD5UaGUgZmluYWwgcHJvbXB0aW5nIG1ldGhvZCBpcyBvdXIgbm92ZWwgPGVtPnVzZSBtaXN0YWtlPC9lbT4gbWV0aG9kLiBJbiB0aGlzIG1ldGhvZCwgd2UgcGFzc2VkIGFuIGVycm9uZW91cyBleGFtcGxlIExMTSBnZW5lcmF0ZWQgc29sdXRpb24gYWxvbmcgd2l0aCB0aGUgcHJvYmxlbS4gVGhlIHByb21wdCB1c2VkIHdhczo8L3A+XG5cbjxibG9ja3F1b3RlPlRoaXMgaXMgYW4gYXR0ZW1wdCB0byB0aGUgZnVuY3Rpb246IFxcXFxuIHtwcm9ibGVtfSBcXFxcbiB7YXR0ZW1wdH0gXFxcXG4gSWYgdGhlIHNvbHV0aW9uIGlzIGNvcnJlY3QgcGxlYXNlIG91dHB1dCB0aGUgZXhpc3RpbmcgZnVuY3Rpb24gY29kZS4gSWYgdGhlIHNvbHV0aW9uIGlzIGluY29ycmVjdCBmaXggYW5kIG91dHB1dCB0aGUgZnVuY3Rpb24gY29kZS4gXFxcXG4ge3Byb2JsZW19LjwvYmxvY2txdW90ZT5cblxuPHA+VGhlIGludGVudGlvbiBiZWhpbmQgdGhpcyBtZXRob2QgaXMgdG8gcHJvbXB0IHRoZSBMTE0gdG8gYmUgbW9yZSBjb2duaXphbnQgYW5kIG1pbmRmdWwgb2YgZXJyb3JzLCBzdWNoIGFzIHRoZSBvbmVzIGluIHRoZSB3cm9uZyBhdHRlbXB0IHRoYXQgdGhleSBhcmUgcGFzc2VkLiBXZSBob3BlZCB0aGF0IHRoaXMgd291bGQgdGhlbiBjb3JyZWxhdGUgdG8gcmVkdWNlZCBudW1iZXIgb2YgZXJyb3JzIGFuZCBiZXR0ZXIgZ2VuZXJhdGVkIHNvbHV0aW9ucy48L3A+XG5cbjxoMz5FdmFsdWF0aW9uPC9oMj5cblxuPHA+V2UgdXNlZCBib3RoIEh1bWFuRXZhbCBhbmQgUHl0aG9uU2FnYSB0byBldmFsdWF0ZSBvdXIgY29kZSBwcm9tcHRpbmcgbWV0aG9kcy4gVGhlIGV2YWx1YXRpb24gbWV0aG9kIHVzZWQgaW4gdGhlIEh1bWFuRXZhbCBwYXBlciwgcGFzcyBAIGssIGhhcyBiZWNvbWUgdGhlIHN0YW5kYXJkIGZvciBtZWFzdXJpbmcgTExNIGNvZGUgZ2VuZXJhdGlvbiBhY2N1cmFjeS4gVGhpcyBzdHJhdGVneSBpbnZvbHZlcyBwYXNzaW5nIHRoZSBzYW1lIHByb21wdCB0byB0aGUgTExNIGsgdGltZXMuIElmIGFueSBvZiB0aGUgayBnZW5lcmF0aW9ucyBwYXNzIGFsbCBvZiB0aGUgdW5pdCB0ZXN0cywgdGhlbiB0aGlzIHByb2JsZW0gaXMgZ2l2ZW4gYSBzY29yZSBvZiBcIjFcIiBmb3Igc29sdmluZyB0aGUgcHJvYmxlbS4gT3RoZXJ3aXNlLCBpdCBpcyBnaXZlbiBhIHNjb3JlIG9mIFwiMFwiLiBDYWxjdWxhdGluZyB0aGUgbWVhbiBvZiB0aGVzZSBzY29yZXMgYWNyb3NzIHRoZSBjb2RlIGV2YWx1YXRpb24gZGF0YXNldCB0aGF0IGlzIGJlaW5nIHVzZWQgdGhlbiB5aWVsZHMgdGhlIGZpbmFsIHNjb3JlLiBXZSBjYWxjdWxhdGVkIHBhc3MgQCAxLCA1LCBhbmQgMTAgZm9yIGFsbCBvZiB0aGUgZGlmZmVyZW50IHByb21wdGluZyBtZXRob2RzLiBGdXJ0aGVybW9yZSwgd2UgcHJvcG9zZSBhIG5vdmVsIGNvbWJpbmVkIG1ldHJpYyB0aGF0IHNob3dzIHRoZSBvdmVyYWxsIGNvbWJpbmVkIHBvd2VyIG9mIHRoZSA8ZW0+YXR0ZW1wdDwvZW0+IGFuZCAgPGVtPnVzZSBtaXN0YWtlPC9lbT4gbWV0aG9kcy4gU2ltcGx5LCB0aGlzIG1ldHJpYyBjaGVja3MgaWYgZWl0aGVyIG9uZSBvZiB0aGVzZSBwcm9tcHRpbmcgbWV0aG9kcyB5aWVsZGVkIGEgY29ycmVjdCBvdXRwdXQuPC9wPlxuXG48aDM+SW1wbGVtZW50YXRpb24gRGV0YWlsczwvaDI+XG5cbjxwPkZvciBvdXIgTExNLCB3ZSB1c2UgT3BlbkFJJ3MgR1BULTMuNSBUdXJibyB3aXRoIGEgdGVtcGVyYXR1cmUgb2YgMC44LCBhcyB0aGF0IGlzIHRoZSBzdGFuZGFyZCB0ZW1wZXJhdHVyZSB1c2VkIHdpdGggSHVtYW5FdmFsLiBXZSBjaG9zZSBHUFQtMy41IFR1cmJvIGR1ZSB0byBzaWduaWZpY2FudGx5IGxvd2VyIGFzc29jaWF0ZWQgY29zdHMgZm9yIHJlcGVhdGVkIExMTSBwYXNzZXMgd2l0aCBkaWZmZXJlbnQgcHJvbXB0cyBhbmQgbWV0aG9kcyBhbmQgR1BULTQgVHVyYm8gYWxyZWFkeSBoYXZpbmcgdGhlIGJlc3QgcGVyZm9ybWFuY2Ugb24gdGhlIEh1bWFuRXZhbCBkYXRhc2V0LiBXZSBob3BlZCB0byBpbmNyZWFzZSBwZXJmb3JtYW5jZSB3aXRoIGEgd29yc2UgYnV0IG11Y2ggY2hlYXBlciBtb2RlbCB0byBzaG93IHRoZSBiZW5lZml0cyBvZiBvdXIgcHJvbXB0aW5nIHRlY2huaXF1ZS4gQWZ0ZXIgMTAgcGFzc2VzIGZvciBlYWNoIHByb2JsZW0sIHdlIHJhbiB0aGUgZ2VuZXJhdGVkIGNvZGUgaW4gYSBEb2NrZXIgY29udGFpbmVyIHRvIGJlbmNobWFyayB1c2luZyB0aGUgdW5pdCB0ZXN0cyBhbmQgc3RvcmUgdGhlIHJlc3VsdHMuIFdlIGFsc28gc3RvcmVkIHRoZSBpbmRpdmlkdWFsIExMTSBnZW5lcmF0ZWQgb3V0cHV0cyBhbmQgYmVuY2htYXJrIHJlc3VsdHMgZm9yIG1vcmUgZGV0YWlsZWQgb3V0cHV0IGFuYWx5c2lzLiBDaGVjayBvdXQgb3VyIGNvZGUgPGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9tY2hhbGVzL2xsbS1jb2RpbmctZXZhbFwiPmhlcmU8L2E+LjwvcD5cblxuPGgzPlJlc3VsdHM8L2gyPlxuXG48cD5GaWd1cmUgMTwvcD5cbjxpbWcgc3JjPVwiL3Byb2plY3RzL2xsbS1jb2RpbmctZXZhbC9maWd1cmUxLnBuZ1wiIGFsdD1cIkZpZ3VyZSAxXCIgIHdpZHRoPVwiNTAwXCI+XG5cbjxwPkZpZ3VyZSAyPC9wPlxuPGltZyBzcmM9XCIvcHJvamVjdHMvbGxtLWNvZGluZy1ldmFsL2ZpZ3VyZTIucG5nXCIgYWx0PVwiRmlndXJlIDJcIiAgd2lkdGg9XCI1MDBcIj5cblxuPHA+RmlndXJlIDM8L3A+XG48aW1nIHNyYz1cIi9wcm9qZWN0cy9sbG0tY29kaW5nLWV2YWwvZmlndXJlMy5wbmdcIiBhbHQ9XCJGaWd1cmUgM1wiICB3aWR0aD1cIjUwMFwiPlxuXG48cD5Mb29raW5nIGF0IEZpZ3VyZSAxIGFuZCBGaWd1cmUgMiwgd2UgY2FuIGNsZWFybHkgc2VlIHRoYXQgdGhlIExMTSBwZXJmb3JtcyBzaWduaWZpY2FudGx5IGJldHRlciBvbiBIdW1hbkV2YWwgdGhhbiBQeXRob25TYWdhLiBUaGlzIG1ha2VzIHNlbnNlIGFzIFB5dGhvblNhZ2EgaXMgbXVjaCBuZXdlciwgYW5kIHRodXMgR1BULTMuNSBoYXMgaGFkIGxlc3MgZXhwb3N1cmUgdG8gaXRzIHByb2JsZW1zLiBGdXJ0aGVybW9yZSwgYXMgdGhlIGF1dGhvcnMgb2YgUHl0aG9uU2FnYSB0cmFuc2Zvcm1lZCB0aGUgY29kaW5nIHByb21wdHMgdG8gYmUgaGFyZGVyIGZvciBMTE1zIHRvIGlkZW50aWZ5IHRoZSB1bmRlcmx5aW5nIHF1ZXN0aW9uL2Z1bmN0aW9uIG9mIHRoZSBwcm9ibGVtLCBpdCBtYWtlcyBzZW5zZSB0aGF0IGFsbCBwcm9tcHRpbmcgbWV0aG9kcyBwZXJmb3JtIHNpZ25pZmljYW50bHkgd29yc2Ugb24gaXQuIEZvciBIdW1hbkV2YWwsIHRoZSA8ZW0+dXNlIG1pc3Rha2U8L2VtPiBwcm9tcHRpbmcgbWV0aG9kIGhhZCB0aGUgYmVzdCBwZXJmb3JtYW5jZSwgd2hpbGUgZm9yIFB5dGhvblNhZ2EsIHRoZSA8ZW0+YXR0ZW1wdDwvZW0+IG1ldGhvZCBwZXJmb3JtZWQgdGhlIGJlc3QuIEdpdmVuIHRoYXQgUHl0aG9uU2FnYSdzIGludm9sdmVkIHByZXByb2Nlc3NpbmcgcmVzdWx0IGluIHNpZ25pZmljYW50bHkgcG9vcmVyIG92ZXJhbGwgcmVzdWx0cywgYW5kIEh1bWFuRXZhbCBpcyB0aGUgbW9yZSB0ZXN0ZWQgZGF0YXNldCwgd2UgY29uZHVjdGVkIG1vc3Qgb2Ygb3VyIGFuYWx5c2lzIHdpdGggSHVtYW5FdmFsLjwvcD5cblxuPHA+SW50ZXJlc3RpbmdseSwgdGhlIDxlbT5hdHRlbXB0PC9lbT4gYW5kIDxlbT51c2UgbWlzdGFrZTwvZW0+IG1ldGhvZHMgZG9uJ3QgZmFpbCB0aGUgc2FtZSBwcm9ibGVtcy4gV2UgY2FuIGNvbWJpbmUgdGhlaXIgcmVzdWx0cyB0byBjcmVhdGUgdGhlIG1ldHJpYyA8ZW0+Q29tYmluZWQ8L2VtPiBmb3IgSHVtYW5FdmFsIHNlZW4gaW4gRmlndXJlIDMuPC9wPlxuXG48aDM+Q29kZSBFeGFtcGxlPC9oMz5cbjxwPk9uZSBwcm9ibGVtIHdoaWNoIDxlbT51c2UgbWlzdGFrZTwvZW0+IHN1Y2NlZWRlZCB3aGlsZSA8ZW0+YXR0ZW1wdDwvZW0+IGRpZCBub3Qgd2FzOjwvcD5cblxuPGJsb2NrcXVvdGU+XCJIb3cgbWFueSA3cyBhcmUgaW4gbnVtYmVycyB0aGF0IGFyZSBkaXZpc2libGUgYnkgMTEgb3IgMTMgYmV0d2VlbiAxIHRvIG4sIHdoZXJlIG4gaXMgYW4gaW5wdXQgcGFzc2VkIGluLlwiPC9ibG9ja3F1b3RlPlxuXG48cD5UaGUgPGVtPmF0dGVtcHQ8L2VtPiBtZXRob2QgZmFpbHMgdG8gdW5kZXJzdGFuZCB0aGF0IG51bWJlcnMgY2FuIGhhdmUgbXVsdGlwbGUgN3MsIGFuZCB0aGF0IHRoZXNlIG5lZWQgdG8gYmUgY291bnRlZCBpbmRpdmlkdWFsbHkuIEFuIGV4YW1wbGUgZ2VuZXJhdGlvbiBpczo8L3A+XG5cbjxwcmU+PGNvZGU+Y291bnQgPSAwXG5mb3IgaSBpbiByYW5nZSgxLCBuKTpcbiAgICBpZiBpICUgMTEgPT0gMCBvciBpICUgMTMgPT0gMDpcbiAgICAgICAgaWYgJzcnIGluIHN0cihpKTpcbiAgICAgICAgICAgIGNvdW50ICs9IDFcbnJldHVybiBjb3VudFxuPC9jb2RlPjwvcHJlPlxuXG48cD48ZW0+dXNlIG1pc3Rha2U8L2VtPiBzdWNjZXNzZnVsbHkgYW5zd2VyZWQgdGhpcyBxdWVzdGlvbiB3aXRoIHRoZSBnZW5lcmF0aW9uOjwvcD5cblxuPHByZT48Y29kZT5jb3VudCA9IDBcbmZvciBpIGluIHJhbmdlKDEsIG4pOlxuICAgIGlmIGkgJSAxMSA9PSAwIG9yIGkgJSAxMyA9PSAwOlxuICAgICAgICBmb3IgZGlnaXQgaW4gc3RyKGkpOlxuICAgICAgICAgICAgaWYgZGlnaXQgPT0gJzcnOlxuICAgICAgICAgICAgICAgIGNvdW50ICs9IDFcbnJldHVybiBjb3VudFxuPC9jb2RlPjwvcHJlPlxuXG48cD5JbnRlcmVzdGluZ2x5LCB0aGUgPGVtPm1pc3Rha2U8L2VtPiBnZW5lcmF0ZWQgY29kZSBmb3IgdGhpcyBzb2x1dGlvbiBpcyBub3QgY2xvc2UgdG8gdGhlIGNvcnJlY3Qgc29sdXRpb246PC9wPlxuXG48cHJlPjxjb2RlPmlmIGkgJSA3ID09IDA6XG4gICAgY291bnQgKz0gMVxuY29udGludWVcbnJldHVybiBjb3VudFxuPC9jb2RlPjwvcHJlPlxuXG48cD5BbHRob3VnaCBub3QgYWx3YXlzIHJlbGlhYmxlLCBtaXN0YWtlLWdlbmVyYXRlZCBvdXRwdXRzIGNhbiBpbmZsdWVuY2UgTExNcyB0byBzb2x2ZSBwcm9ibGVtcyB0aGV5IHByZXZpb3VzbHkgY291bGQgbm90LjwvcD5cblxuPGgzPkNvbmNsdXNpb24gQkxBSEJMQUg8L2gyPlxuXG48cD5UaGlzIHByb2plY3QgcHJvcG9zZXMgYSBuZXcgcHJvbXB0aW5nIHRlY2huaXF1ZSBmb3IgTExNcyB0aGF0IHJlc3VsdGVkIGluIGltcHJvdmVkIHBlcmZvcm1hbmNlIHdpdGggSHVtYW5FdmFsIHBhc3MgQCAxMC4gTW9yZSByZXNlYXJjaCB3aWxsIG5lZWQgdG8gYmUgZG9uZSB0byBleHBsb3JlIHJlcGVhdGFiaWxpdHkgYW5kIHJlbGlhYmlsaXR5IG9mIHRoaXMgdGVjaG5pcXVlLjwvcD5cblxuPGgzPkV4dHJhPC9oMz5cblxuPHRhYmxlPlxuICA8dGhlYWQ+XG4gICAgPHRyPlxuICAgICAgPHRoPlByb21wdGluZyBUZWNobmlxdWU8L3RoPlxuICAgICAgPHRoPkh1bWFuRXZhbCBQYXNzQDE8L3RoPlxuICAgICAgPHRoPkh1bWFuRXZhbCBQYXNzQDU8L3RoPlxuICAgICAgPHRoPkh1bWFuRXZhbCBQYXNzQDEwPC90aD5cbiAgICAgIDx0aD5QeXRob25TYWdhIFBhc3NAMTwvdGg+XG4gICAgICA8dGg+UHl0aG9uU2FnYSBQYXNzQDU8L3RoPlxuICAgICAgPHRoPlB5dGhvblNhZ2EgUGFzc0AxMDwvdGg+XG4gICAgPC90cj5cbiAgPC90aGVhZD5cbiAgPHRib2R5PlxuICAgIDx0cj5cbiAgICAgIDx0ZD5BdHRlbXB0PC90ZD5cbiAgICAgIDx0ZD48c3Ryb25nPjcxLjI4PC9zdHJvbmc+PC90ZD5cbiAgICAgIDx0ZD44NC44NTwvdGQ+XG4gICAgICA8dGQ+ODkuMDI8L3RkPlxuICAgICAgPHRkPjxzdHJvbmc+MTguODE8L3N0cm9uZz48L3RkPlxuICAgICAgPHRkPjxzdHJvbmc+MzEuMzI8L3N0cm9uZz48L3RkPlxuICAgICAgPHRkPjxzdHJvbmc+MzUuNjg8L3N0cm9uZz48L3RkPlxuICAgIDwvdHI+XG4gICAgPHRyPlxuICAgICAgPHRkPk1pc3Rha2U8L3RkPlxuICAgICAgPHRkPjEwLjA2PC90ZD5cbiAgICAgIDx0ZD4zNS44MDwvdGQ+XG4gICAgICA8dGQ+NTMuMDU8L3RkPlxuICAgICAgPHRkPjEuNjg8L3RkPlxuICAgICAgPHRkPjcuNDY8L3RkPlxuICAgICAgPHRkPjEyLjk3PC90ZD5cbiAgICA8L3RyPlxuICAgIDx0cj5cbiAgICAgIDx0ZD5Vc2UgTWlzdGFrZTwvdGQ+XG4gICAgICA8dGQ+NzAuNzk8L3RkPlxuICAgICAgPHRkPjxzdHJvbmc+ODguNDE8L3N0cm9uZz48L3RkPlxuICAgICAgPHRkPjxzdHJvbmc+OTEuNDY8L3N0cm9uZz48L3RkPlxuICAgICAgPHRkPjE2LjAwPC90ZD5cbiAgICAgIDx0ZD4yNy41NzwvdGQ+XG4gICAgICA8dGQ+MzIuNDM8L3RkPlxuICAgIDwvdHI+XG4gICAgPHRyPlxuICAgICAgPHRkPlVzZSBBdHRlbXB0PC90ZD5cbiAgICAgIDx0ZD42Ni42NTwvdGQ+XG4gICAgICA8dGQ+ODQuODg8L3RkPlxuICAgICAgPHRkPjg3LjgwPC90ZD5cbiAgICAgIDx0ZD4xMy42ODwvdGQ+XG4gICAgICA8dGQ+MjQuNDk8L3RkPlxuICAgICAgPHRkPjI3LjAzPC90ZD5cbiAgICA8L3RyPlxuICA8L3Rib2R5PlxuPC90YWJsZT5cbmA7XG4iXSwibmFtZXMiOlsiZGVzY3JpcHRpb24iLCJjb250ZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/data/projects/content/llm-coding-eval.ts\n"));

/***/ })

});